# Лабораторная работа №3

**Тема:** Использование принципов проектирования на уровне методов и классов
**Цель работы:** Получить опыт проектирования и реализации модулей с использованием принципов KISS, YAGNI, DRY и SOLID.

## Диаграмма компонентов
### BotService
Данный сервис необходим для работы с телеграмм-ботом: прием и отправка сообщений, генерация сообщений на основе данных из базы и изменение информации в базе на основе приходящих сообщений.

<p align="center">
<img src="../src/Diagrams/4C - BotService.png" width="500" title="4C - BotService">
</p>

В данном случае нас будет интересовать части, связанные с сервисом статистики и работой репозитория базы данных.
### StatisticsService
Сервис предназначен для генерации сообщений, содержащих данные о статистике конкретного работника или всех работников компании.

<p align="center">
<img src="../src/Diagrams/4C - StatisticsService.png" width="500" title="4C - StatisticsService">
</p>

### TrackerRepository
Репозиторий предназначен для работы с базой данных (реализация операций CRUD).

<p align="center">
<img src="../src/Diagrams/4C - TrackerRepository.png" width="500" title="4C - TrackerRepository">
</p>


## Диаграмма последовательностей
Так как при работе с репозиториев базы данных и сервисами, связанными с ним, не возникает потребности в проектировании сложной логики методов, то были построены sequence диаграммы только для компоненты StatisticsService. В нее входят два больших прецедента, которые показаны далее: прецедент "Просмотр личной статистики отработанного времени" и прецедент "Просмотр подробной статистики по сотрудникам компании".
### Просмотр личной статистики отработанного времени

<p align="center">
  <img src="../src/Diagrams/SequenceDiagram - личная статистика.png" width="500" title="SequenceDiagram - личная статистика">
</p>


### Просмотр подробной статистики по сотрудникам компании

<p align="center">
<img src="../src/Diagrams/SequenceDiagram - статистика по компании.png" width="600" title="SequenceDiagram - статистика по компании">
</p>


## Модель БД
На диаграмме представлены пять классов базы данных с используемыми методами. Здесь, при реализации, использовался похожий вид, однако вместо атрибута типа private и соответствующих ему методов get/set использовался краткий вариант: public string Attribute { get; set; }, так как отстутвовала необходимость в преобразовании данных для записи в базу данных или выводе из базы данных.

<p align="center">
<img src="../src/Diagrams/ClassDiagram - Database.png" width="800" title="ClassDiagram - Database">
</p>


## Применение основных принципов разработки
Рассмотрим парадигмы программирования SOLID, KISS, YAGNI и DRY на примере проекта "Тайм-трекер рабочего времени".

### Работа с базой данных:
Были реализованы классы сущностей DBUser, DBTask, DBGPS и базовый класс DBEntity. 

#### DRY
При этом был использован принцип DRY при создании базового класса. Так как поля, содержащиеся в нем (на данном этапе только Id) не повторяются в классах наследниках.

#### YAGNI
Был использован принцип YAGNI - не было создано интерфейсов для сервисов DBTaskService и DBGPSService, так как, при текущем описании задачи, для них не требуется функциональность, отличная от базового класса. То есть, интерфейсы были бы пустыми.

#### KISS
Был использован принцип KISS - все методы сервисов достаточно короткие и однотипные, что позволяет быстро понять их функционал.

#### SOLID
Для работы с сущностями были созданы сервисы DBTaskService, DBUserService, DBGPSService и базовый DBService. При их проектировании использовались принципы SOLID:
#### S - Single Responsibility:
Для работы с каждой отдельной сущностью был реализован отдельный сервис, таким образом, для каждого сервиса выделяется одна конкретная причина для существования;
#### L - Liskov Substitution:
Базовый класс был создан в виде обобщенного класса, соответственно каждый класс-наследник будет реализовывать все функции, обозначенные в базовом классе по-своему (для своего типа данных). А так как будут реализованы все функции базового класса, то присутствующие в программе потомки, могут заменяться объектами родительского типа без негативных последствий для функциональности программы;
#### I - Interface Segregation:
Для сервисов DBTaskService и DBUserService был создан интерфейс IDBEntityWithNameService, включающий в себя функцию поиска элемента в базе данных по имени. Класс DBGPSService не имплементирует этот интерфейс, так как в нем нет необходимости - в классе DBGPS нет поля name.

### Работа со статистикой:

#### SOLID
Были созданы классы WorkerStatisticsService, AdminStatisticsService, базовый класс StatisticsService и интерфейс IStatisticsService. При их проектировании использовались принципы SOLID:
#### O - Open-Closed:
Благодаря созданию интерфейса, пропадает необходимость модифицировать основной класс, соответственно класс становится открытым  для расширения, но закрытым для модификации.
#### D - Dependency Injection:
При дальнейшей работе с приложением может возникнуть необходимость добавления новых групп сотрудников с другим отображением статистики. В таком случае введение дополнительной абстракции в виде интерфейса IStatisticsService позволяет убрать прямую зависимость модулей верхнего уровня от модулей нижнего уровня.

## Дополнительные принципы разработки
### BDUF - Big design up front (масштабное проектирование прежде всего)
На данный момент принцип масштабного проектирования применяется в особенности в отношении проектирования базы данных (была построена диаграмма классов для сущностей и декомпозирована диаграмма 4C до уровня кода для сервисов). Также принцип использовался для сервиса статистики (4С диаграмма декомпозирована до уровня кода) и проекта в целом (была построена диаграмма прецедентов и проведена декомпозиция 4C до уровня компонент).
### SoC - Separation оf concerns (принцип разделения ответственности)
Принцип разделения ответственности используется в проекте при работе с базой данных - отделяется логика серверной части проекта от логики работы с базой данных. Это осуществляется засчет наличия репозитория и сервисов, которые осуществляют логику работы с базой данных.
### MVP - Minimum viable product (минимально жизнеспособный продукт)
MVP системы будет реализован по окончании работы над проектом. После чего полученный продукт будет тестироваться в рамках компании и дорабатываться до готового решения, способного выйти на рынок.
### PoC - Proof of concept (доказательство концепции)
На данный момент доказательством комнцепции можно считать проведенный анализ предметной области и существующих литературных источников, указывающих на жизнеспособность идеи системы и высокую вероятность того, что она будет решить поставленную задачу.
